#######################
#####  Questions ######
#######################

# - Why would you want to create Dynamic function in Kotlin? A function that dynamically creates another function? Like :

    // Creating a function that returns a created function
		fun makeMathFunction(num1: Int): (Int) -> Int = { num2 -> num1 * num2 }

	// Using above function
	    val multiple3 = makeMathFunction(3)

####################
#####  Theory ######
####################

# - About Kotlin

- Strongly typed language, but has 'Type Inference' to reduce boiler plate code.
- Kotlin can be run as a script too.
- Can work with IntelliJ / Eclipse.
- Can be mixed with your Java Code.
- As project size increases, instead of compiling the whole project again and again which is gona take more time with time.
  we can enable 'Incremental Build' by

        1. Create a file called 'gradle.properties' along side build.gradle 
        2. Add "kotlin.incremental=true" to this file

# - Visibility Modifier / Access Levels / Access Modifiers

    -> There are 4 :
        > private
            top level class, interface, function can only be accessed from the same class, interface or object

        > protected
            Visible to members and subclass

        > internal
            Visible in the same module

        > public
            Visible everywhere, default modifier

# - Immutable vs Mutable (Compare with Java String class)

        - How do u make mutable or immutable?
        - var can be reassigned, val are read only
        - Advantages of Immutable
                -> Thread Safe
                -> More robust and predictable
                -> Follows open closed principle by default
                -> so just use ‘val’ as much as possible

    We need not infer the data types again and again, so we can simple do

    Val s = “Example”
    Val I = 23
    Val actionBar = supportActionBar

# - In Kotlin, Everything is an object, there are no primitive data type hence its ‘purely object oriented’

# - Basic Data Types :

        -> There are basic data types such as 

            * Int | 32
            * Long | 64
            * Short | 16
            * Byte | 8
            * Double | 64
            * Float | 32

            Code :
                val int = 123
                val long = 123456L
                val double = 12.34
                val float = 12.34F
                val hexadecimal = 0xAB
                val binary = 0b01010101

        -> There is no implicit casting / widening this time as it was in Java. 
            There are certain methods like

                Val d : Double = intValue.toDouble() and there are more like 

                    toByte(), toShort(), toInt(),
                    toLong(), toFloat(), toDouble(), toChar()
            
            * Characters
            * Boolean

        -> Characters can’t be used as numbers, you have to use

	           charVal.toInt()


# - Strings can be treated as array and can be iterated over.

    -> val stringValue = “Dhananjay”

    -> Strings are IMMUTABLE here also. Difference between 

            println("""hello \n world""")
            println("hello \n world")

            """ ARE 

                    EXTREMELY

                USEFUL""" 

    -> val index = stringValue[2] // Returns Char ‘a’

    -> Strings have iterator function too, so string reverse programs are simpler now.

            for (c in stringVal) {
                print(c)
            }

    -> String have an extension function which helps in looping over the Strings


# - Arrays

        -> We have arrayOf() function with different variants
                
            A simple one :
                    
                val array = arrayOf(1, 2, 3)
            
                With initial size and function,
                    
                    val perfectSquares = Array(10, { k -> k * k })

                emptyArray() function

                val deck : Array<KotlinCard> = emptyArray()
            
        -> Here this array will always be empty, hence we need to initialize it right now. So we initialize the array with a single card.

            class Deck {
                val deck : Array<KotlinCard> = arrayOf(KotlinCard(0, "Clubs", false))
            }

        -> Arrays have extension function called as indicies which help iterate over the index of array
            for (index in array.indicies) {
                println("At $index we have ${array[index]}")
            }


# - LOGICAL OPERATORS LIKE ‘or’ and ‘and’ exists LITERALLY! similarly, shr shl are also there

# - Expression vs Statements

    * Statements don't evaluate to anything
        val a = 1
        If..else, try..catch in Java 

    * Expressions evaluate to something
        "hello".startsWith("h")
        If..else, try..catch in Kotlin

        val date = Date()
        val today = if (date.year == 2016) true else false
        fun isZero(x: Int): Boolean {
            return if (x == 0) true else false
        }

# - Ranges and Loops

    val aToz = "a".."z"
    val oneToNince = 1..9

    The range will be >= start value and <= end value

    anotherRange = range.step()

    You can create negative ranges and iterate over them like 
        
        val negativeRange = -100..100
        for(num in negativeRange) print(num)

        val list = listOf(1, 2, 3, 4)
        for (k in list) {
            println(k)
        }

        val set = setOf(1, 2, 3, 4)
        for (k in set) {
            println(k)
        }

        val oneToTen = 1..10
        for (k in oneToTen) {
            for (j in 1..5) {
                println(k * j)
            }
        }

    Any object can be used inside a for loop as long as it implements 'iterator function'  which returns
        - hasNext() : Boolean and -next() : T

    IMPORTANT NOTE :
    
        Ranges are compiled into index-based for loops which are supported by JVM and hence avoid any performance impact which creation of iterator object may have.    
        
# - Exception Handling :

    -> All exceptions are same as that in Java, ONLY THIS TIME THERE ARE NO CHECKED EXCEPTIONS just like in C++
    -> So no need of writing more code in front of your function declaration.
    -> Be careful while writing sensetive code, although the compiler will give you suggestions and Kotlin is null safe so you need not worry about Exceptions MOST of the times.

    -> An example of Exception Handling would be :

        fun readFile(path: Path): Unit {
             val input = Files.newInputStream(path)
             try {
               var byte = input.read()
               while (byte != -1) {
                 println(byte)
                 byte = input.read()
               }
             } catch (e: IOException) {
               println("Error reading from file. Error was ${e.message}")
             } finally {
               input.close()
            }
        }

        val success = try {
            readFile()
            true
            }
            catch (e: IOException) {
            false
        }

# - Functions

        class Deck {

            fun indexToCard(i: Int): KotlinCard {
                val value = i % 13
                val suit = when (i / 13) {
                    0 -> "Clubs"
                    1 -> "Diamonds"
                    2 -> "Hearts"
                    else -> "Spades"
                }
                return KotlinCard(value, suit)
            } // End of function

            val deck : Array<KotlinCard> = arrayOf(KotlinCard(0, "Clubs", false))

        } // End of class

       We can remove the function name to make it anonymous.

# - EXTENSIONS FUNCTIONS
    
    -> We can add behaviour to an existing class even without modifying or seeing its source code. Pretty cool, this is not extending a class because you are not writing a different class. So you can use ’this’ keyword in your extension functions and access that class public methods.

# - Smart Casts

    In Java :

        public void printStringLength(Object obj) {
             if (obj instanceof String) {
               String str = (String) obj
               System.out.print(str.length())
             }
        }

    In Kotlin :

        fun printStringLength(any: Any) {
             if (any is String) {
               println(any.length)      // Compiler sees if it itself evaluated 'any' as a 'String' 
                                        // hence executes the code
             }
        }

# - Kotlin Objects Classes and Constructors

    -> Creating Objects : Remember in Java, constructors are same as methods and while calling them we use 'new' but here constructors are same as functions so no 'new' keyword.

        val file = File("/etc/nginx/nginx.conf")
        val date = BigDecimal(100)
        

    -> There is a default constructor in Kotlin too just like Java, but if you want to customise the way the    objects are initialized you have to define your own constructors. Constructor is followed immediately by the Class name. Your class can have an init block, which can be used to initialize the properties of your class.

        class KotlinCard (value : Int, suit : String, faceUp : Boolean) {
            val value: Int
            val suit : String = suit
            var faceUp : Boolean = faceUp

            init {
                this.value = value
            }
        }

    -> Kotlin will avoid writing redundant code, if your fields are not private, you cannot declare a set / get method as Kotlin implicitly has those methods in place and will give you a "declaration clash"

    -> Constructors passed params have a limited scope by the way, you can't use them everywhere.

    -> So till now, you class can look like this :

        class KotlinCard (value : Int, suit : String, faceUp : Boolean) {
            val value: Int = value
            val suit : String = suit
            var faceUp : Boolean = faceUp
        }

    -> This can further be simplified, you can add the val/var keywords in the constructor itself like this :

        class KotlinCard (val value : Int,val suit : String,var faceUp : Boolean) {

        }

    -> You can also initialize the value in the header

        class KotlinCard(val value: Int = 2, val suit: String = "", var faceUp: Boolean = false) {

        }

# - Referential equality and structural equality

    val a = File("/mobydick.doc")
    val b = File("/mobydick.doc")

    -> Equality is of two types in OOPS :
        
        1. Two seperate references point to same memory location. [REFERNTIAL]

            * We use === OR !== to check for referential

                Example : 

                    val sameRef = a === b  // Returns false

        2. Two objects have different memory locations but have same structure. [STRUCTURAL]
            * It is upto the creator of the class to define what structural equality means.
            * We use == OR != to check for structural integrity
            * == is null safe too.

                    val sameRef = a == b // Returns True

# - 'this' expression : Current Reciever

    class Person(name: String) {
         fun printMe() = println(this)
    }

    'this' inside a function refers to the Class Instance.
    'this' inside an extension function referst to the instance of that extension function.

# - Scope and Labels:

    class Building(val address: String) {
         inner class Reception(telephone: String) {
           fun printAddress() = println(this@Building.address)
         }
    }   

# - Getters and Setters exist by default

# - Kotlin properties must be defined or the type must be abstract. ; are optional by the way.

        class KotlinCard {
        	val value: Int
        		get() {
        		return 0
        	}
        }

        And This can be rewritten as :

        class KotlinCard {
            val value: Int
            get() = 0
        }

        And That can be rewritten as :

        class KotlinCard {
            val value: Int = 0
        }

        So this is how you create properties :

        class KotlinCard {
            val value: Int = 0
            val suit : String = ""
            var faceUp : Boolean = false
        }


########################
######    OOPS    ###### 
########################

# - Object : 

    > Run time instance of class
    > An object is nothing but a block of memory allocated and configured according to a design/definition.
    > Kotlin supports :

            - Encapsulation
                Grouping related fields and methods.

            - Inheritence
                Creating a new class from an existing one.

            - Polymorphism
                Different classes can have different implementation of a same method.

            - Abstraction


# OOPS helps in making things : ( If designed correctly )
    - Simplicity
        Models real world scenraio while reducing complexity

    - Modularity
        Each object has their own role and responsibility

    - Modifiability
        Change affects only that object

    - Extensibility
        Changes can be made by modifying the exisiting objects.

    - Reusability
        Your classes can be used in other programs / projects

# You should know : 

    - How to define classes or interfaces.
    - When to choose interfaces over classes.
    - When to choose inheritence over composition.
    

#############################
######    FUNCTIONS    ###### 
#############################


* Functions are defined using 'fun' keyword and a return value. 

    fun hello() : String = "hello World"

    fun hello(name : String, location : String) : String = "hello $name at $location"

* Void is called Unit here, and can be omitted by the developer if he wishes so.

    fun print1(str: String): Unit {
         println(str)
    }
       fun print2(str: String) {
         println(str)
    }

* Must declare the return type except for single expression functions.

    fun concat1(a: String, b: String) = a + b
    
    fun concat2(a: String, b: String): String {
        return a + b 
    }

* Member function can refer themselves and they don't need the instance name, just like Java.

* Local Functions :

    Split program into smaller chunks, helps in Reusability, DRY Code.

    In Java, you can have a helper class containing Static functions which can be reused at multiple places.

    In kotlin, you can declare FUNCTIONS INSIDE FUNCTIONS. These are local or Nested functions, and can be nested multiple times. This is helpful when you have functions calling some other function which is just there to support it, hence those functions can be nested to protect / hide from outside program which doesn't really need to see it.

* Top Level Functions :

    Similar to static function in Java which are inside the helper class. 
    They are defined inside a file, and dont belong to any class.

* Named Parameters are used to pass your arguments in the order you want. It makes your code more readable, and not all params have to be named. Works only with Kotlin defined functions and not Java defined functions

    Example : 

        deleteFiles("*.jpg", true, true, false)
        deleteFiles("*.jpg", recursive = true, ignoreCase = true, deleteDirectories = false)

* Default Parameters

    Helps reducing the number of functions you declare for various number of attributes.

* Extension Functions 

    - Helps extending the capability of an existing class without Extending / Modifying it.
    - To use the extension function you have to import the particular method.
    - Cannot override the existing function of a class, compiler will never invoke it. 
    - Compiler first looks for exact matching function in the class, superclasses or interfaces.
    - You can differentiate using the number of parameters.
    - You can also define extension functions inside classes if you want to restrict the extensability of these functions.
    - Extension functions can be overriden by defining them as 'open'

###########################
######    LAMBDAS    ###### 
###########################

# - Higher Order Functions
    
    - Help us write Cleaner and more expressive code
    - A higher order function is simply a function that either accepts another function as a param, or returns a function as its return value or BOTH.

    - Example :
        fun foo(str: String, fn: (String) -> String): Unit {
            val applied = fn(str)
            println(applied)
        }

        Here the function foo gets two parameters, one is a String. Second is a function that takes a String and returns a String. The format is like (input_Type) -> output_Type.

    - Imperative approach to find out even and odd numbers 

        val ints = listOf(1, 2, 3, 4, 5, 6)
        val evens = mutableListOf<Int>()
        val odds = mutableListOf<Int>()
        for (k in ints) {
          if (k % 2 == 0)
            evens.add(k)
          else
            odds.add(k)
        }

    -  Functional, quicker, easier to read code

        val ints = listOf(1, 2, 3, 4, 5, 6)
        val odds = ints.filter { it % 2 == 1 }
        val evens = ints.filter { it % 2 == 0 }

        Also, we can do : Return a function 

           fun modulo(k: Int): (Int) -> Boolean = { it % k == 0 }
           val ints = listOf(1, 2, 3, 4, 5, 6)
           val odd = ints.filter(modulo(1))
           val evens = ints.filter(modulo(2))
           val mod3 = ints.filter(modulo(3))


    - Lets consider function to reverse a String :

        fun reverseString(s : String) : String {
            return s.reversed()
        }

        fun reverseStringInLine() : (String) -> String = {str -> str.reversed()}

        Its a function, that returns another function

    - Function Assingment

        Functions can also be assigned to variables to make it easier for them to be passed around 

            val isEven : (Int) -> Boolean = modulo(2)

            listOf(1, 2, 3, 4).filter(isEven)

    - Closures

        - Functions which have access to outer variables hence name is Closure [Close Over]

        class Student(val firstName: String, val lastName: String)
           fun loadStudents(): List = ...
              //  load from database
           fun students(nameToMatch: String): List<Student> {
             return loadStudents().filter {
               it.lastName == nameToMatch
             }
        }


#######################################
######    ANDROID WITH KOTLIN    ###### 
#######################################

# - Anko is a great library developed by Jetbrains along with Kotlin, So instead of

    val forecastList = findViewById<RecyclerView>(R.id.forecast_list) We can do
	val forecastList : RecyclerView = find(R.id.forecast_recycler_view)
	Anko is really cool and can help with a lot of Boiler plate code which we write on Android, whether it be Intent instantiation, Creation of Fragments, Database operations, Alerts and a lot more…

# - Anko provides methods too, like :

        toast(“Hello World”) which is an extension function in itself
        longToast(R.string.helloWorld)
        We can create EXTENSION PROPERTIES TOO! Example later!

# - NETWORKING

        Kotlin provides many extension function which helps do networking operations without using third party libraries.

# - ASYNC TASKS : help take up the load off the UI thread but they can dangerous if not properly handled, plus by the time code reaches onPostExecute() the Activity could be destroyed and our Task will also crash.
		so Anko is here to help us with that

			doAsync() {
			    // Code
			}

# - A little information about Threading :

    - UI Thread has different implementations depending upon the the caller object
    - When used by UI Thread, it wont be executed if the Activity.isFinishing(). Because it wont be safe / good practice to do operations when your activity is not in place.
    - If false at least we know the Activity's destruction has not been triggered.


    ## Java has java.util.concurrent.Future

        Learn more : https://www.baeldung.com/java-future

        - The Future class represents a future result of an asynchronous computation – a result that will eventually appear in the Future after the processing is complete
        - Useful for doing computational intensive operations and remote calls.

        ### See Java Code To Understand Future:

            import java.util.concurrent.*;

            public class JavaClass {
                private ExecutorService executorService = Executors.newSingleThreadExecutor();

                public Future<Integer> calculate(Integer input) {
                    return executorService.submit(new Callable<Integer>() {
                        @Override
                        public Integer call() throws Exception {
                            Thread.sleep(3000);
                            return input * input;
                        }
                    });
                }


                public static void main(String[] args) throws InterruptedException, ExecutionException {
                    JavaClass javaClass = new JavaClass();
                    // javaClass.calculate(3);
                    // Will simply just calculate and spit out the result

                    // To gain control while computation :
                    Future<Integer> integerFuture = new JavaClass().calculate(4);

                    System.out.print("Calculating");
                    while (!integerFuture.isDone()) {   // While not done
                        System.out.print("..");
                        Thread.sleep(500);
                    }
                    System.out.println();
                    System.out.println(integerFuture.get());

                }
            }

            // Other ways to control your Future is using
                .cancel() and there is a isCancelled() method to check if cancelled
                .get(long timeUnit) <- Will throw TimeOut exception if your future doesn't return a value

            // Release the resources with a Shutdown() method

                ## Code example 2 :

                    SquareCalculator squareCalculator = new SquareCalculator();

                    Future<Integer> future1 = squareCalculator.calculate(10);
                    Future<Integer> future2 = squareCalculator.calculate(100);

                    while (!(future1.isDone() && future2.isDone())) {
                        System.out.println(
                          String.format(
                            "future1 is %s and future2 is %s",
                            future1.isDone() ? "done" : "not done",
                            future2.isDone() ? "done" : "not done"
                          )
                        );
                        Thread.sleep(300);
                    }

                    Integer result1 = future1.get();
                    Integer result2 = future2.get();

                    System.out.println(result1 + " and " + result2);

                    squareCalculator.shutdown();

                ## Code Example 2 output :

                    calculating square for: 10
                    future1 is not done and future2 is not done
                    future1 is not done and future2 is not done
                    future1 is not done and future2 is not done
                    future1 is not done and future2 is not done
                    calculating square for: 100
                    future1 is done and future2 is not done
                    future1 is done and future2 is not done
                    future1 is done and future2 is not done
                    100 and 10000

            Since the above process is taking time, to make it Parallel

# - doAsyncResult is something that you can use to get result back from the doAsync {

}

# - DATA CLASS :

     We had POJO Classes in JAVA, they are also simplified.

     Implicitly the methods are generated but we can modify :

        getters and setters()
        equals()
        hashcode()
        copy()
        mapping object to variable

     Copying a data class :

        Since we have immutability in Kotlin, so to create another modified object is a resourceful task hence we have copy() method which is a much more efficient way to do so.
        Example :

            val f1 = Forecast(Date(), 27.5f, "Shiny Day")
            val f2 = f1.copy(temperature = 30f)

            Try to not modify the object and copy it instead if you can.

            There is another practice of creating a Wrapper Class to deal with immutability, Learn more about this.

    >> Mapping Object into Variables

        "Declaration Destruction" when we map each property inside an object into a variable

        val f1 = Forecast(Date(), 27.f, "Shiny Day") , Let's say we have this object

        So if we "Declare Destruct" it, It would be something like :

            val (date, temperature, details) = f1

            which eventually means :

                val date = f1.date()
                val temperature = f1.temp()
                val details = f1.details()

# - Kotlin Companion Object

        There is no static keyword in Java, so you wont be facing issues of referencing a non static from static context
        In Kotlin we have Companion Objects.
        There is no static class, hence we use objects which are companion objects which we can reference from anywhere we want.
        They help implement Singleton Pattern.
        They cannot be declared inside a local class.

                class ForecastRequest(val zipCode : String) {
                    companion object {
                        private val APP_ID = "12312313"
                        private val URL = "https://google.com"
                    }
                }

# Interfaces in Kotlin are different han that of JAVA because we can insert code.










